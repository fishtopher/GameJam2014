using UnityEngine;
//using UnityEditor;
using System.Collections;
using System.Collections.Generic;

[ExecuteInEditMode]
public partial class Spline : MonoBehaviour
{
	public bool m_closed;
	public float m_hermiteTightness = 0.5f;
	float m_prevFrameTightness = 0.5f;

	public float m_bakeResolution = 5;

	[HideInInspector]
	public List<SplinePoint> m_points = new List<SplinePoint>();
	public int m_numRealPoints { get { return m_points.Count - 2; } } // Points 0 and Count-1 are hidden and only used for the hermite calculations
	public SplinePoint FirstPoint { get { return m_points[1]; } }
	public SplinePoint LastPoint { get { return m_points[m_points.Count - 2]; } }


	[HideInInspector]
	public float Length { get; private set; }

	[HideInInspector]
	public bool IsDirty {get; private set;}
	[HideInInspector]
	public bool HasChanged {get; private set;}

	// Doing this otherwise we get autogenerated points hanging around as the
	//	points (child objects) are destroyed before the spline (parent) and
	//	during RemovePoint(), SanityCheck() makes sure there are a minimum of
	//	two points.
	void OnDestroy()
	{
		for(int i = 0; i < m_points.Count; i++)
		{
			m_points[i].removeFromSpline = false;
		}
	}

	void Awake()
	{
		Length = CalculateLengthHermite();
	}

	void Start ()
	{
		SanityCheck();
	}
	
	//
	void LateUpdate()
	{
		IsDirty = false;
		
		// check we're clean
		if(m_hermiteTightness != m_prevFrameTightness)
		{
			IsDirty = true;
			m_prevFrameTightness = m_hermiteTightness;
		}
		else
		{
			for(int i = 0; i < m_points.Count; i++)
			{
				if(m_points[i].IsDirty)
				{
					IsDirty = true;
					break;
				}
			}
		}	

		if(IsDirty)
		{
			CalculateHiddenPoints();
			Length = CalculateLengthHermite(); 
			SanityCheck();
		}
	}

	// This could probably be made into a generic extension method
	int GetIndexOf(SplinePoint p)
	{
        for(int i = 0; i < m_points.Count; i++)
		{
			if(m_points[i] == p)
			{
				return i;
			}
		}
		return -1;
	}

	public void InsertPointAfter(SplinePoint p)
	{
		int idx = GetIndexOf(p);
		if(idx >= 0 && idx < m_points.Count)
			InsertPointAfter(idx);
	}

	public void InsertPointAfter(int after)
	{
		CalculateHiddenPoints();

		Vector3 a = m_points[after].transform.position;
		Vector3 b = m_points[after+1].transform.position;
		Vector3 np = Vector3.Lerp(a, b, 0.5f);

		GameObject ngo = new GameObject("p" + (after+1));
		ngo.transform.position = np;
		SplinePoint nsp = ngo.AddComponent(typeof(SplinePoint)) as SplinePoint;
		ngo.transform.parent = transform;
		m_points.Insert(after+1, nsp);

		RenamePoints();
		CalculateHiddenPoints();
		SanityCheck();

#if UNITY_EDITOR
		PostInsertPoint(nsp.gameObject);
#endif
	}

	public void InsertPointBefore(SplinePoint p)
	{
		int idx = GetIndexOf(p);
		if(idx >= 0 && idx < m_points.Count)
			InsertPointAfter(idx-1);
	}


	public void RemovePoint(SplinePoint p)
	{
		int idx = GetIndexOf(p);
		if(idx >= 0 && idx < m_points.Count)
		{
			m_points.RemoveAt(idx);
			RenamePoints();
		}

		SanityCheck();
	}

	void AlignPoints()
	{
		for(int i = 1; i < m_points.Count-1; i++)
		{
			Vector3 p1 = m_points[i-1].transform.position;
			Vector3 p2 = m_points[i+1].transform.position;

			Vector3 fwd = p2 - p1;
			m_points[i].transform.rotation = Quaternion.LookRotation(fwd, m_points[i].transform.up);
		}
	}

	// Splines must have at minimum 2 points!
	public void SanityCheck()
	{
		// Add first Hidden Point
		if(m_points.Count == 0)
		{
			GameObject ngo = new GameObject("p-1");
			SplinePoint nsp = ngo.AddComponent(typeof(SplinePoint)) as SplinePoint;
			ngo.transform.position = transform.position + transform.forward * -10;
			ngo.transform.parent = transform;
			ngo.hideFlags = HideFlags.NotEditable | HideFlags.HideInHierarchy;
			m_points.Add(nsp);
		}
		
		// Add first Real Point
		if(m_points.Count == 1)
		{
			GameObject ngo1 = new GameObject("p0");
			SplinePoint nsp1 = ngo1.AddComponent(typeof(SplinePoint)) as SplinePoint;
			ngo1.transform.position = transform.position;
			ngo1.transform.parent = transform;
			m_points.Add(nsp1);
		}
		
		// Add second Real Point
		if(m_points.Count == 2)
		{
			GameObject ngo1 = new GameObject("p1");
			SplinePoint nsp1 = ngo1.AddComponent(typeof(SplinePoint)) as SplinePoint;
			ngo1.transform.position = m_points[1].transform.position + m_points[1].transform.forward * 10;
			ngo1.transform.parent = transform;
			m_points.Add(nsp1);
		}

		// Add final Hidden Point
		if(m_points.Count == 3)
		{
			GameObject ngo1 = new GameObject("p2");
			SplinePoint nsp1 = ngo1.AddComponent(typeof(SplinePoint)) as SplinePoint;
			ngo1.hideFlags = HideFlags.NotEditable | HideFlags.HideInHierarchy;
			ngo1.transform.position = m_points[2].transform.position + m_points[2].transform.forward * 10;
			ngo1.transform.parent = transform;
			m_points.Add(nsp1);
		}

		if(m_closed)
			m_points[m_points.Count-2].transform.position = m_points[1].transform.position;

		m_points[0].gameObject.hideFlags = HideFlags.NotEditable | HideFlags.HideInHierarchy;
		m_points[m_points.Count-1].gameObject.hideFlags = HideFlags.NotEditable | HideFlags.HideInHierarchy;

		CalculateHiddenPoints();
		AlignPoints();
		Length = CalculateLengthHermite();
		
		SplineMesh sm = GetComponent<SplineMesh>();
		if(sm != null)
		{
			sm.RebuildMesh();
		}
	}

	public void CalculateHiddenPoints()
	{
		if(m_closed)
		{
			m_points[0].transform.position = m_points[m_points.Count-3].transform.position;
			m_points[m_points.Count-1].transform.position = m_points[2].transform.position;
		}
		else
		{
			Vector3 d = m_points[1].transform.position - m_points[2].transform.position;
			m_points[0].transform.position = m_points[1].transform.position + d;
			
			d = m_points[m_points.Count-2].transform.position - m_points[m_points.Count-3].transform.position;
			m_points[m_points.Count-1].transform.position = m_points[m_points.Count-2].transform.position + d;
		}
	}
	//
	public void RenamePoints(int startFrom = 0)
	{
        for(int i = startFrom; i < m_points.Count; i++)
			m_points[i].name = "p" + (i-1);
	}

	// -------------------------------------
	//	Hermite
	//
	public void PointAndTangentAtNormalisedTime(float t, out Vector3 point, out Vector3 tangent)
	{
		t = Mathf.Clamp01(t);
		point = PointAtNormalisedTime(t);
//		tangent = Quaternion.Slerp(m_points[m_lastIdx].transform.rotation, m_points[m_lastIdx+1].transform.rotation, m_lastPart) * Vector3.forward;

		const float o = 0.01f;
		if(t < (1-o))
		{
			Vector3 p2 = PointAtNormalisedTime(t + o);
			tangent = (p2 - point).normalized;
		}
		else
		{
			Vector3 p2 = PointAtNormalisedTime(t - o);
			tangent = (point - p2).normalized;
		}
	}
	
//	int m_lastIdx;
//	float m_lastPart;
	public Vector3 PointAtNormalisedTime(float t)
	{
		if(t <= 0)
		{
//			m_lastIdx = 1;
			return m_points[1].transform.position;
		}
		if(t >= 1)
		{
//			m_lastIdx = m_points.Count - 2;
			return m_points[ m_points.Count - 2 ].transform.position;
		}

	    float idxf = t * (m_points.Count - 3) ;
		int idx = Mathf.Clamp((int)idxf, 0, m_points.Count - 1);
		float s = idxf - idx;

		// m_point[0] is a special hidden point, so make sure we start from [1] instead
		idx++;
//		m_lastIdx = idx;
//		m_lastPart = idxf - idx;

	    float h1 = (2 * s * s * s) - (3 * s * s) + 1; // calculate basis function 1
	    float h2 = (-2 * s * s * s) + (3 * s * s);    // calculate basis function 2
	    float h3 = (s * s * s) - (2 * s * s) + s;     // calculate basis function 3
	    float h4 = (s * s * s) - (s * s);             // calculate basis function 4

	    Vector3 P1 = m_points[idx].transform.position;
		Vector3 P1_prev = m_points[idx - 1].transform.position;
		Vector3 P1_next = m_points[idx + 1].transform.position;

	    idx = idx + 1;
		Vector3 P2 = m_points[idx].transform.position;
		Vector3 P2_prev = m_points[idx - 1].transform.position;
		Vector3 P2_next = m_points[idx + 1].transform.position;

	    Vector3 T1 = m_hermiteTightness * ( P1_next - P1_prev );
	    Vector3 T2 = m_hermiteTightness * ( P2_next - P2_prev );

	    Vector3 a = h1 * P1;
	    Vector3 b = h2 * P2;
	    Vector3 c = h3 * T1;
	    Vector3 d = h4 * T2;

	    Vector3 final = a + b + c + d;

	    return final;
	}

	public void PointAndTangentAtTime(float timeIn, out Vector3 point, out Vector3 tangent)
	{
		float len = 0;
		float t = 0;
		float step = 1.0f / ((m_points.Count-1) * m_bakeResolution);
		Vector3 p1 = PointAtNormalisedTime(t);
		while(t < 1)
		{
			t += step;

			Vector3 p2 = PointAtNormalisedTime(t);
			float mag = (p2-p1).magnitude;
			float newLen = len + mag;
			if(len <= timeIn && newLen > timeIn)
			{
				float interp = (timeIn-len) / mag;
				point = Vector3.Lerp(p1, p2, interp);
				tangent = (p2-p1).normalized;
				return;
			}
			len = newLen;
			p1 = p2;
		}

		PointAndTangentAtNormalisedTime(1, out point, out tangent);
	}

	float CalculateLengthHermite()
	{
		float len = 0;

		float t = 0;
		float step = 1.0f / ((m_points.Count-1) * m_bakeResolution);
		Vector3 p1 = PointAtNormalisedTime(t);
		while(t < 1)
		{
			t += step;
			Vector3 p2 = PointAtNormalisedTime(t);
			len += (p2-p1).magnitude;
			p1 = p2;
		}

		return len;
	}
}